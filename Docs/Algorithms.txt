Алгоритмы, реализованные в библиотеке, являются усовершенствованными версиями известных алгоритмов
разбора выражений. Более детальная информация здесь:

http://ru.wikipedia.org/wiki/Обратная_польская_запись
http://msdn.microsoft.com/ru-ru/library/ms139741.aspx

Алгоритм компиляции исходного выражения.

Для каждого элемента последовательности:

  1. Если элемент является константой или переменной, добавляем его к результирующей строке.
  2. Если элемент является открывающей скобкой, помещаем его в стек.
  3. Если элемент является закрывающей скобкой, выталкиваем элементы из стека в выходную строку
     до тех пор, пока на вершине стека не окажется открывающаяся скобка. При этом открывающая
     скобка удаляется из стека, но в выходную строку не добавляется. Если после этого шага на вершине
     стека оказывается символ функции, выталкиваем его в выходную строку. Если стек закончился раньше,
     чем мы встретили открывающуюся скобку, это означает, что в выражении несогласованы скобки.
  4. Если элемент является разделителем аргументов функции (запятая), то выталкиваем элементы из стека
     в выходную строку до тех пор, пока верхним элементом стека не станет открывающаяся скобка.
     Если открывающаяся скобка не встретилась, это означает, что в выражении либо неверно поставлен
     разделитель, либо несогласованы скобки.
  5. Если элемент является одной из зарегистрированных сигнатур[*], то:
     - Если элемент соответствует сигнатуре унарного оператора и этот элемент - первый после начала выражения
       (либо начало входной последовательности, либо сразу после открывающей скобки), мы интерпретируем его как
       унарный оператор и заносим в стек в соответствии с его приоритетом и ассоциативностью[**]. Далее
       осуществляется незамедлительный переход к обработке следующего эл-та (continue).
     - Если элемент соответствует сигнатуре бинарного оператора, то заносим его в стек в соответствии с его
       приоритетом и ассоциативностью. Далее осуществляется незамедлительный переход к обработке следующего эл-та (continue).
     - Если элемент соответствует сигнатуре одной из составных частей оператора, принимающего 3 или более
       операндов, то определяем номер этой составной части (для двоеточия в тернарном операторе ?: это будет
       номер 1, для знака вопроса - номер 2). Если номер равен 1, то заносим его в стек в соответствии с его приоритетом
       и ассоциативностью[**]. Если номер больше 1, то выталкиваем в результирующее выражение все элементы,
       пока не найдем составную часть с предыдущим номером.
       Если оказывается, что обработанный таким способом элемент замыкает сигнатуру оператора, то соединяем в стеке
       его части в один логический оператор. Если предыдущий не найден - синтаксическая ошибка.
     - Если элемент соответствует сигнатуре функции, добавляем его в стек.

После того, как входная последовательность целиком обработана, выталкиваем из стека все оставшиеся там операторы.

*
  Все поддерживаемые операторы и функции зарегистрированы, то есть имеют сигнатуру (из каких знаков
  состоит), кол-во операндов (если больше 2, то оператор имеет составную сигнатуру, как, например, ?: -
  каждая из ее частей обладает порядковым номером), приоритет вычисления и ассоциативность (левая ил правая).
  Когда по позиции в строке мы запрашиваем сигнатуру, реестр операций возвращает нам коллекцию, каждый элемент
  которой является частью зарегистрированной сигнатуры. К примеру, на запрос "-" вернется коллекция из двух
  элементов: один - для унарного оператора отрицания, а другой будет относиться к бинарной операции.
  Наш алгоритм рассматривает их в порядке увеличения числа операндов.
**
  Если текущий оператор - левоассоциативный, то выталкиваем все операторы из стека, пока не найдется оператор,
  приоритет которого меньше, чем у текущего.
  Если текущий оператор - правоассоциативный, то выталкиваем все операторы из стека, пока не найдется оператор,
  приоритет которого либо меньше, либо равен текущему.
  После этого добавляем текущий оператор в стек.
  Процесс выталкивания может выполняться, пока не будет достигнут разделитель (скобка, запятая), неполная
  сигнатура оператора или дно стека.

Примечание:
  1. При "выталкивании" из стека мы должны смотреть, нет ли среди тех элементов, которые мы должны
     вытолкнуть, незавершенных сигнатур операторов. Если такие обнаруживаются, - это сигнал о синтаксической
     ошибке. Вообще, при принудительном выталкивании у нас не должно быть ничего, кроме завершенных
     операторов. Если встречается что-либо другое (например, скобка при выталкивании в самом конце алгоритма) -
     значит, где-то была допущена синтаксическая ошибка.
  2. При занесении любого элемента в стек либо в результирующее выражение осуществляется незамедлительный
     переход к обработке следующего элемента последовательности.
     
     
Алгоритм обратного преобразования.

Возвращает строку, соответствующую указанной последовательности констант, переменных и операций над ними.
Операции могут быть функциями и операторами. Необходимо формализовать алгоритм преобразования последовательности вида
a 3 5 + * в строку a*(3+5). Идея простая и работает аналогично процессу вычисления результата с использованием стека вычислений.
Только в данном случае элементом стека вычислений будет не просто double-значение, а строка-операнд с указанием последней операции,
над ним произведенной. К примеру, строка "3+5" с указанием того, что последней операцией было бинарное сложение.

Для каждого элемента входной последовательности.

Если элемент является операндом (константа или переменная), добавляем его в стек вычислений.
Иначе (если элемент - либо оператор, либо функция)
	Если элемент - функция, то обрамляем аргументы в сигнатуру и скобки, вне зависимости от того, требуют ли скобок аргументы.
		(синус будет выглядеть так - "sin(<здесь будет операнд функции>)"
	Далее, мы извлекаем из стека вычислений требуемое кол-во операндов (для sin один, для бинарных операторов - 2, итд)
	Для каждого операнда мы должны определить, следует ли заворачивать его в скобки. Для этого необходимо следовать правилам:
		1. Простой операнд (одиночная константа или переменная) не обрамляется скобками
		2. Если последняя операция, произведенная над операндом - унарная, то следует ее обернуть в скобки
		3. Аргументы функции не оборачиваются в скобки (к примеру, "f(12,c+4,var_0)") - достаточно начального обрамления в сигнатуре f(...)
		   это правило следует из высшего приоритета запятой
		4. Аргументы операторов, которые не являются крайними (как, например, операнд y в выражении x?y:z) тоже не нужно оборачивать скобками.
		5. Крайние аргументы операторов должны оборачиваться скобками только в тех случаях, когда это необходимо для
		   соблюдения выбранного порядка вычисления (по приоритетам):
		   - если внешняя операция имеет больший приоритет по сравнению с последней операцией на операнде
		     из этого также следует то, что функции не оборачиваются скобками (например, "sin(c)+4")
		   - если (приоритеты равны) и (рассматриваемый операнд - самый правый) и (приоритет является лево-ассоциативным)
		     к примеру, "a" "b-c" [-] => "a-(b-c)"
		   - если (приоритеты равны) и (рассматриваемый операнд - самый левый) и (приоритет является право-ассоциативным)
		     к примеру, выражение (a?b:c)?d:e
	Формируем строку операндов, и, если внешняя операция - функция, вставляем в сигнатуру функции f().
	Добавляем сформированный элемент на стек вычислений вместо использованных операндов.

Результат работы алгоритма будет лежать на вершине стека вычислений.